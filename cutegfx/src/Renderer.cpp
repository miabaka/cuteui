#include "cutegfx/Renderer.hpp"

#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>

using namespace cutegfx;

template<class... Ts>
struct overloaded : Ts ... {
	using Ts::operator()...;
};

template<class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

static unsigned char VERTEX_SHADER_CODE[] = {
		0x44, 0x58, 0x42, 0x43, 0x1d, 0x4e, 0xc6, 0x61, 0xd9, 0xee, 0x7d, 0x6a, 0x0f, 0x0b, 0x5b, 0xda,
		0x73, 0xbf, 0x8b, 0xe0, 0x01, 0x00, 0x00, 0x00, 0xac, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x2c, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x4e,
		0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x03, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x50, 0x4f, 0x53, 0x49,
		0x54, 0x49, 0x4f, 0x4e, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0xab, 0x4f, 0x53, 0x47, 0x4e,
		0x4c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0f, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f,
		0x52, 0x00, 0x53, 0x56, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0xab, 0xab,
		0x53, 0x48, 0x44, 0x52, 0xd4, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x35, 0x00, 0x00, 0x00,
		0x59, 0x00, 0x00, 0x04, 0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x5f, 0x00, 0x00, 0x03, 0x32, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x03,
		0xf2, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xf2, 0x20, 0x10, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xf2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05,
		0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x38, 0x00, 0x00, 0x08, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x15, 0x10, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x00, 0x0a, 0xf2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xf2, 0x20, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x46, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x8e, 0x20, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01
};

static unsigned char PIXEL_SHADER_CODE[] = {
		0x44, 0x58, 0x42, 0x43, 0x68, 0xb5, 0xc2, 0x08, 0x20, 0x31, 0xd3, 0x17, 0x48, 0x29, 0xd8, 0xb7,
		0xfb, 0x70, 0xa5, 0x13, 0x01, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x2c, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x49, 0x53, 0x47, 0x4e,
		0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0f, 0x0f, 0x00, 0x00, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x00, 0xab, 0xab, 0x4f, 0x53, 0x47, 0x4e,
		0x2c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x0f, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5f, 0x54, 0x41, 0x52, 0x47, 0x45, 0x54, 0x00, 0xab, 0xab,
		0x53, 0x48, 0x44, 0x52, 0x38, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
		0x62, 0x10, 0x00, 0x03, 0xf2, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03,
		0xf2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0xf2, 0x20, 0x10, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x46, 0x1e, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x01
};

Renderer::Renderer(const ctl::RcPtr<Device> &device)
		: _device(device),
		  _vertexBuffer(device->createBuffer(Buffer::Type::Vertex)),
		  _indexBuffer(device->createBuffer(Buffer::Type::Index)),
		  _constantBuffer(device->createBuffer(Buffer::Type::Constant)),
		  _pixelShader(device->createShader(Shader::Type::Pixel, PIXEL_SHADER_CODE, sizeof(PIXEL_SHADER_CODE))),
		  _vertexShader(device->createShader(Shader::Type::Vertex, VERTEX_SHADER_CODE, sizeof(VERTEX_SHADER_CODE))) {
	_vertexBuffer->setLayout(
			{{"POSITION", Buffer::ElementType::Float2},
			 {"COLOR",    Buffer::ElementType::Float4}},
			_vertexShader
	);
}

ctl::RcPtr<Viewport> Renderer::createViewport() {
	return _device->createViewport();
}

void Renderer::setViewport(const ctl::RcPtr<Viewport> &viewport) {
	submitCurrentMesh();
	_commandList.emplace_back(SetViewportCommand{viewport});
}

void Renderer::resize(glm::uvec2 size) {
	submitCurrentMesh();
	_commandList.emplace_back(ResizeCommand{size});
}

void Renderer::clear(glm::vec4 color) {
	submitCurrentMesh();
	_commandList.emplace_back(ClearCommand{color});
}

void Renderer::fillRect(glm::vec2 p1, glm::vec2 p2, glm::vec4 color) {
	MeshBuilder::index_t firstIndex = _meshBuilder.addRect(p1, p2, color);

	if (!_hasIncompleteMesh)
		_firstIncompleteMeshIndex = firstIndex;

	_hasIncompleteMesh = true;
}

void Renderer::render() {
	submitCurrentMesh();
	_meshBuilder.uploadAndReset(*_vertexBuffer, *_indexBuffer);

	_vertexShader->use();
	_pixelShader->use();
	_vertexBuffer->use();
	_indexBuffer->use();

	ctl::RcPtr<Viewport> viewport;

	for (auto &command: _commandList) {
		std::visit(overloaded{
				[&](SetViewportCommand &cmd) {
					viewport = cmd.viewport;
					viewport->use();
				},
				[&](ClearCommand &cmd) { viewport->clear(cmd.color); },
				[&](ResizeCommand &cmd) {
					glm::vec2 size = cmd.size;
					glm::mat4 projection = glm::ortho(0.f, size.x, size.y, 0.f);

					_constantBuffer->setData(static_cast<void *>(&projection), sizeof(projection));
					_constantBuffer->use();

					viewport->resize(cmd.size);
				},
				[&](DrawMeshCommand &cmd) { _device->draw(cmd.firstIndex, cmd.indexCount); }
		}, command);
	}

	_commandList.clear();
}

void Renderer::submitCurrentMesh() {
	if (!_hasIncompleteMesh)
		return;

	_hasIncompleteMesh = false;

	DrawMeshCommand command{};

	command.firstIndex = _firstIncompleteMeshIndex;
	command.indexCount = _meshBuilder.currentIndex() - command.firstIndex;

	_commandList.emplace_back(command);
}